# 系统级IO

## 1.Unix I/O
> 一个Linux文件就是一个m个字节的序列

所有的I/O设备（例如网络，磁盘，终端）都被模型化为文件，输入与输出会被看作是文件操作。这种将设备映射为文件的方式为UnixI/o 
+ **打开文件**。一个程序可以通过要求内核打开相应的文件来宣告它想要访问一个I/o设备
+ Linux shell 创建的每个进程开始时都有**三个打开的文件**:标准输入（描述符为0，STDIN_FILENO），标准输出（描述符为1,STDOUT_FILENO）标准错误（描述符为2,STDERR_FILENO）
+ 改变当前文件位置。 文件位置k初始为0，记录了从文件开始的字节偏移量，程序可以通过执行**seek**操作显示的设置文件位置
+ 读写文件。从文件之中复制n个字节到内存。若是文件位置是k，就复制到k+n个，如果文件字节大小是m但是k>=m是会发出EOF的条件==文件末尾并没有所谓的EOF标志，但是应用可以检测这个条件==
+ 关闭文件。完成访问之后，程序通知内核释放刚刚用来文件操作的内存。

## 2.文件
每个linux文件都有一个类型(type)
+ 普通文件包含任意数据。文本文件是只有ASCLL或者Unicode字符的普通文件，二进制文件是其他所有文件。对内核而言文本文件与二进制文件没有任何区别
+ 目录
+ 套接字是用来与另一个进程进行跨网络通信的文件
+ 其他文件 。。 

linux内核将所有的文件都组织成一个目录层次结构，由' /' (根目录)确定，根目录是所有文件的祖先

作为其上下文的一步分，每个进程都有一个当前工作目录来确定目录层次结构中的当前位置。
+ 绝对路径
+ 相对路径

## 3.打开和关闭文件

进程通过调用open函数来打开一个已存在的文件或者创建一个新文件

open函数成功则返回新文件描述符，若出错返回-1

新文件的描述符返回**最小的文件描述符**，比如程序默认打开三个文件为 0 1 2 之后再打开文件其描述符就是 3

flags 参数指明了进程打算如何访问这个文件:
+ O_RDONLY : 只读
+ O_WRONLY: 只写
+ O_RDWR: 只读只写

flags 也可以是一个或者更多位掩码的或
+ O_CREAT : 文件不存在就创建它的一个空文件
+ O_TRUNC： 文件已经存在就截断它
+ O——APPEND: 每次写操作的时候定位到文件的结尾

mode参数指定了新文件的访问权限


## 4.读和写文件

应用程序调用read函数与write函数来执行输入与输出的

```cpp
#include<unistd.h>

ssize_t read(int fd , void *buf , size_t n);
    若成功返回读取的字节数，出错为-1
ssize_t write(int fd,const void *buf , size_t n);
```

read函数从描述符为fd的当前文件位置复制n个字节到buf

wirte函数从buf复制n个字节到描述符fd的当前文件位置。

`lseek 函数可以显示修改当前文件的位置`

在某些情况之下read和write传送的字节比应用程序要求要少，这些不足值不表示有错误

## 5.用RIO包健壮地读写


RIO包回自动处理不足值。
RIO提供了两类不同的函数
### 无缓冲的输入输出函数。
这些函数直接在文件和内存之中传送数据。

通过调用 rio_readn 以及 rio_writen 函数，应用程序可以在内存和文件之间直接传送数据。
### 带缓冲的输入函数

## 6.读取文件元数据

应用程序可以通过调用start和fstat函数来检索到关于文件的信息(有时也叫文件的元数据)

## 7.读取目录内容

用readdir系列函数来读取目录的内容

## 8.共享文件

可以用许多不同的方式来共享Linux文件。
内核用三个相关的数据结构来表示打开的文件

+ **描述符表**:每个进程都有独立的描述符表。每个描述符表项指向文件表终端一个表项
+ **文件表**: 打开文件的集合是由一张文件表来表示的，所有的进程共享这一张表。每个文件表的表项组成(针对我们的目的)包括**文件位置，引用计数，以及指向v-code表中对应表项的指针**。知道引用计数为 0 才会删除这一表项
+ v-node 表，所有进程共享，每个表项包含了stat结构之中的大多数信息

多个描述符也可以通过不同的文件表项来引用同一个文件。这样它们指向的v-node表就会相同

我们也能理解父子进程是如何共享文件的
+ 子进程有一个父进程描述表的副本，父子进程共享相同的打开文件表的集合
+ 在内核删除相应的文件表项之前，父进程必须都关闭了它们的描述符(只有描述符为0才能删除)
而同一个文件用创建两个描述符，其指向的文件表是不同的，所以不会影响文件指针。

## 9.I/O 重定向

Linux shell 提供了I/O 重定向操作符，允许用户将磁盘文件以及标准输入输出联系起来。
`ls > foo.txt`

shell加载ls程序，将标准输出重定向到磁盘文件foo.txt之中。

当一个Web服务器代表客户端运行CGI程序时，它就执行一种相似类型的重定向。

`int dup2(int oldfd , int newfd)`

+ dup2函数赋复制描述符表表项oldfd到描述符表项newfd进行覆盖。
+ 如果newfd已经打开，dup2会在复制oldfd之前关闭newfd。