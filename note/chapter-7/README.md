# 链接
+ 链接是将各种代码和数据片段收集并组合成为一个单一文件的过程，该文件可以被加载(复制)到内存之中执行

## 1.编译器驱动程序

执行 `linux> gcc -Og -o prog main.c sum.c`

+ 驱动程序首先运行c预处理器，将c的源程序main.c翻译成ASCLL码中间文件main.i
+ 驱动程序运行c编译器将main.i 翻译成ASCLL汇编语言文件main.s
+ 驱动程序运行汇编器将main.s 翻译为可重定位的目标文件main.o
+ 链接器将,o文件以及一些系统文件组合起来生成可执行文件

## 2.静态链接

为了构造可执行文件，连接器完成以下两个主要任务:
+ 符号解析(symbol resolution)
+ 重定位(relocation) 

## 3. 目标文件
+ 可重定位文件（.o）
+ 可执行目标文件(.exe)
+ 共享目标文件。一种类型特殊的可重定位目标文件，可以在加载或者运行时被动态加载进内存并且链接

## 4.可重定位目标文件

+ ELF头 ： 16个字节的序列，描述了生成该文件的系统的字的大小和字节顺序
+ .text: 已编译程序的机器代码
+ .rodata: 只读数据
+ .data 已经初始化的全局和静态变量
+ .bass 未初始化或者被初始化为0的全局或者静态变量
+ .symtab 符号表，存放程序之中定义和引用的函数和全局变量的信息
+ .rel.text 一个.test节中位置的列表
+ .rel.data : 被模块引用或者定义的全局变量的重定位信息
+ .debug 调试表，只用-g选项时会生成


## 5.符号和符号表

每个可重定位目标模块m都有一个符号表,包含m定义和引用的符号信息。有三种符号
+ 模块m定义并能被其他模块引用的全局符号。对应于非静态的c函数和全局变量
+ 由其他模块定义，并被模块m引用的全局符号。（外部符号） 对应于在其他模块定义的非静态的c函数和全局变量
+ 只被模块m定义和引用的全局符号。对应于带static属性的c函数和全局变量。

定义为带有c static 属性的本地过程变量是不在栈之中管理

符号表
+ name 是字符串表之中的字节偏移.
+ value 是符号的地址，对应据目标节的偏移、
+ size是目标的大小
+ type 要么是数据要么是函数

三个伪节
+ ABS 代表不该被重定位的符号
+ UNDEF代表未定义的符号,也就是在本目标模块之中引用，定义在别处的符号
+ COMMOM 表示未初始化的全局变量 // .bass 表示未初始化的静态变量以及初始化为0的全局或静态变量

## 6.符号解析
### 链接器如何处理多重定义的全局符号
在编译时，编译器想汇编器输出每个全局符号，或者时强，或者时弱
+ 强符号: 函数和已经初始化的全局变量
+ 弱符号: 没有初始化的全局变量
  
以下规则处理多重定义的符号名:
+ 不允许由多个同名的强符号
+ 如果由一个强符号和多个弱符号同名，选择强符号
+ 如果有多个弱符号同名，任意选择一个

链接器通常不会表明它检测到多个x的定义，也就是说两个模块之中同时定义了x，这不会报错


考虑以下示例: foo5.c bar5.c
+ 由于double类型时8个字节，而int时4个字节。所以double x 此时x实际上对应foo5.c之中的强符号x，修改x之后会覆盖x

所以说没有初始化的全局变量是common 因为它对应的值不确定，而没有初始化的静态变量不会被其他模块覆盖，所以其对应的值确定，分配到.bss的节之中

### 写静态库链接

实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件 -- 静态库 ，作为链接器的输入

linux系统之中，静态库以一种存档的特殊文件存放。 存档文件后缀为 .a 

`linux> gcc -static -o prog main.0 ./libverctor.a`

链接时，会从 libverctor.a 文件之中寻找所需要的.o文件
static 参数告诉编译器驱动程序构建一个完全链接的可执行目标文件


### 链接器如何使用静态库来解析引用
由于连接器从左到右按照舒徐来扫描目标文件，所以要注意其出现顺序

连接器维护一个可重定位目标文件的集合E,一个引用但是尚未定义的集合U，以及一个在输入文件之中以及定义的符号集合D

+ 若是可重定位文件则放入E之中，修改U与D的集合
+ 若是.a文件，查看成员文件之中哪一个.o文件定义了u之中的引用，将该文件放入E之中并且修改u与D
+ 指导UD不发生变化，此时不包含在E之中的成员目标文件都被简单丢弃，然后链接器处理下一文件
+ 最后若U时非空的，产生错误
## 7 重定位

重定位分为两步:
+ 重定位和符号定义:合并所有模块的节section
+ 重定位节之中的符号引用。由于链接时不确定未定义函数最后的位置，所有要进行重定位。链接器修改代码节和数据节之中对每个符号的引用，指向正确的运行地址。此步骤以来与可重定位目标模块之中的**重定位条目**的数据结构

### 重定位条目

由于对数据代码的最后位置未知，所以会先生成一个重定位条目，告诉目标文件合并生成执行文件时如何修改这个引用

+ 代码的重定位条目放在.rel.text之中，已经初始化数据的重定位条目放在.del.data之中

```cpp

typedef struct {
    long offset // 需要被修改的引用的节偏移
    long type : 32 // 如何需改新的引用
    ,symbol:32; //被修改引用应该指向的符号
    long addend; // 用它对被修改引用的值做偏移调整
} Elf64_Rela
```

有以下两种类型: 
+ 重定位相对地址引用
+ 重定位绝对地址引用